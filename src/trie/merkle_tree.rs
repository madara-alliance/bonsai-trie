#[cfg(not(feature = "std"))]
use alloc::{format, string::ToString, vec, vec::Vec};
use bitvec::{
    prelude::{BitSlice, BitVec, Msb0},
    view::BitView,
};
use core::iter::once;
use core::marker::PhantomData;
use core::mem;
use derive_more::Constructor;
#[cfg(not(feature = "std"))]
use hashbrown::HashMap;
use parity_scale_codec::{Decode, Encode};
#[cfg(feature = "std")]
use rayon::prelude::*;
use starknet_types_core::{felt::Felt, hash::StarkHash};
#[cfg(feature = "std")]
use std::collections::HashMap;

use crate::{error::BonsaiStorageError, id::Id, BonsaiDatabase, KeyValueDB};

use super::{
    merkle_node::{BinaryNode, Direction, EdgeNode, Node, NodeHandle, NodeId},
    path::Path,
    trie_db::TrieKeyType,
    TrieKey,
};

#[cfg(test)]
use log::trace;

#[derive(Debug, PartialEq, Eq)]
pub enum Membership {
    Member,
    NonMember,
}

/// Wrapper type for a [HashMap<NodeId, Node>] object. (It's not really a wrapper it's a
/// copy of the type but we implement the necessary traits.)
#[derive(Clone, Debug, PartialEq, Eq, Default, Constructor)]
pub struct NodesMapping(HashMap<NodeId, Node>);

/// A node used in proof generated by the trie.
///
/// See pathfinders merkle-tree crate for more information.
#[derive(Debug, Clone, PartialEq)]
pub enum ProofNode {
    Binary { left: Felt, right: Felt },
    Edge { child: Felt, path: Path },
}

impl ProofNode {
    pub fn hash<H: StarkHash>(&self) -> Felt {
        match self {
            ProofNode::Binary { left, right } => H::hash(left, right),
            ProofNode::Edge { child, path } => {
                let mut bytes = [0u8; 32];
                bytes.view_bits_mut::<Msb0>()[256 - path.0.len()..].copy_from_bitslice(&path.0);
                // SAFETY: path len is <= 251
                let path_hash = Felt::from_bytes_be(&bytes);

                let length = Felt::from(path.0.len() as u8);
                H::hash(child, &path_hash) + length
            }
        }
    }
}

pub(crate) struct MerkleTrees<H: StarkHash + Send + Sync, DB: BonsaiDatabase, CommitID: Id> {
    pub db: KeyValueDB<DB, CommitID>,
    pub trees: HashMap<Vec<u8>, MerkleTree<H>>,
}

#[cfg(feature = "bench")]
impl<H: StarkHash + Send + Sync, DB: BonsaiDatabase + Clone, CommitID: Id> Clone
    for MerkleTrees<H, DB, CommitID>
{
    fn clone(&self) -> Self {
        Self {
            db: self.db.clone(),
            trees: self.trees.clone(),
        }
    }
}

impl<H: StarkHash + Send + Sync, DB: BonsaiDatabase, CommitID: Id> MerkleTrees<H, DB, CommitID> {
    pub(crate) fn new(db: KeyValueDB<DB, CommitID>) -> Self {
        Self {
            db,
            trees: HashMap::new(),
        }
    }

    pub(crate) fn init_tree(
        &mut self,
        identifier: &[u8],
    ) -> Result<(), BonsaiStorageError<DB::DatabaseError>> {
        let tree = MerkleTree::new(&mut self.db, identifier.to_vec())?;
        self.trees.insert(identifier.to_vec(), tree);
        Ok(())
    }

    pub(crate) fn set(
        &mut self,
        identifier: &[u8],
        key: &BitSlice<u8, Msb0>,
        value: Felt,
    ) -> Result<(), BonsaiStorageError<DB::DatabaseError>> {
        let tree = self.trees.get_mut(identifier);
        if let Some(tree) = tree {
            tree.set(&mut self.db, key, value)
        } else {
            let mut tree = MerkleTree::new(&mut self.db, identifier.to_vec())?;
            tree.set(&mut self.db, key, value)?;
            self.trees.insert(identifier.to_vec(), tree);
            Ok(())
        }
    }

    pub(crate) fn get(
        &self,
        identifier: &[u8],
        key: &BitSlice<u8, Msb0>,
    ) -> Result<Option<Felt>, BonsaiStorageError<DB::DatabaseError>> {
        let tree = self.trees.get(identifier);
        if let Some(tree) = tree {
            tree.get(&self.db, key)
        } else {
            Ok(None)
        }
    }

    pub(crate) fn contains(
        &self,
        identifier: &[u8],
        key: &BitSlice<u8, Msb0>,
    ) -> Result<bool, BonsaiStorageError<DB::DatabaseError>> {
        let tree = self.trees.get(identifier);
        if let Some(tree) = tree {
            tree.contains(&self.db, key)
        } else {
            Ok(false)
        }
    }

    pub(crate) fn db_mut(&mut self) -> &mut KeyValueDB<DB, CommitID> {
        &mut self.db
    }

    pub(crate) fn reset_to_last_commit(
        &mut self,
    ) -> Result<(), BonsaiStorageError<DB::DatabaseError>> {
        for tree in self.trees.values_mut() {
            tree.reset_to_last_commit(&mut self.db)?;
        }
        Ok(())
    }

    pub(crate) fn db_ref(&self) -> &KeyValueDB<DB, CommitID> {
        &self.db
    }

    pub(crate) fn db(self) -> KeyValueDB<DB, CommitID> {
        self.db
    }

    pub(crate) fn root_hash(
        &self,
        identifier: &[u8],
    ) -> Result<Felt, BonsaiStorageError<DB::DatabaseError>> {
        let tree = self.trees.get(identifier);
        if let Some(tree) = tree {
            Ok(tree.root_hash())
        } else {
            Err(BonsaiStorageError::Trie("Tree not found".to_string()))
        }
    }

    pub(crate) fn get_keys(
        &self,
        identifier: &[u8],
    ) -> Result<Vec<Vec<u8>>, BonsaiStorageError<DB::DatabaseError>> {
        self.db
            .db
            .get_by_prefix(&crate::DatabaseKey::Flat(identifier))
            .map(|key_value_pairs| {
                // Remove the identifier from the key
                key_value_pairs
                    .into_iter()
                    .map(|(key, _value)| key[identifier.len()..].to_vec())
                    .collect()
            })
            .map_err(|e| e.into())
    }

    pub(crate) fn commit(&mut self) -> Result<(), BonsaiStorageError<DB::DatabaseError>> {
        #[cfg(not(feature = "std"))]
        let db_changes = self
            .trees
            .iter_mut()
            .map(|(_, tree)| tree.get_updates::<DB>())
            .collect::<Result<Vec<_>, BonsaiStorageError<DB::DatabaseError>>>()?;
        #[cfg(feature = "std")]
        let db_changes = self
            .trees
            .par_iter_mut()
            .map(|(_, tree)| tree.get_updates::<DB>())
            .collect::<Result<Vec<_>, BonsaiStorageError<DB::DatabaseError>>>()?;

        let mut batch = self.db.create_batch();
        for changes in db_changes {
            for (key, value) in changes {
                match value {
                    InsertOrRemove::Insert(value) => {
                        self.db.insert(&key, &value, Some(&mut batch))?;
                    }
                    InsertOrRemove::Remove => {
                        self.db.remove(&key, Some(&mut batch))?;
                    }
                }
            }
        }
        self.db.write_batch(batch)?;
        Ok(())
    }

    pub(crate) fn get_proof(
        &self,
        identifier: &[u8],
        key: &BitSlice<u8, Msb0>,
    ) -> Result<Vec<ProofNode>, BonsaiStorageError<DB::DatabaseError>> {
        let tree = self.trees.get(identifier);
        if let Some(tree) = tree {
            tree.get_proof(&self.db, key)
        } else {
            Err(BonsaiStorageError::Trie("Tree not found".to_string()))
        }
    }

    pub(crate) fn get_identifiers(&self) -> Vec<Vec<u8>> {
        self.trees.keys().cloned().collect()
    }
}

/// A Starknet binary Merkle-Patricia tree with a specific root entry-point and storage.
///
/// This is used to update, mutate and access global Starknet state as well as individual contract
/// states.
///
/// For more information on how this functions internally, see [here](super::merkle_node).
pub struct MerkleTree<H: StarkHash> {
    /// The handle to the current root node could be hash if no modifications has been done
    /// since the last commit or in memory if there are some modifications.
    root_handle: NodeHandle,
    /// The last known root hash. Updated only each commit. (possibly outdated between two commits)
    root_hash: Felt,
    /// Identifier of the tree in the database.
    identifier: Vec<u8>,
    /// This storage is used to avoid modifying the underlying database each time during a commit.
    storage_nodes: NodesMapping,
    /// The id of the last node that has been added to the temporary storage.
    latest_node_id: NodeId,
    /// The list of nodes that should be removed from the underlying database during the next commit.
    death_row: Vec<TrieKey>,
    /// The list of leaves that have been modified during the current commit.
    cache_leaf_modified: HashMap<Vec<u8>, InsertOrRemove<Felt>>,
    /// The hasher used to hash the nodes.
    _hasher: PhantomData<H>,
}

// NB: #[derive(Clone)] does not work because it expands to an impl block which forces H: Clone, which Pedersen/Poseidon aren't.
#[cfg(feature = "bench")]
impl<H: StarkHash> Clone for MerkleTree<H> {
    fn clone(&self) -> Self {
        Self {
            root_handle: self.root_handle.clone(),
            root_hash: self.root_hash.clone(),
            identifier: self.identifier.clone(),
            storage_nodes: self.storage_nodes.clone(),
            latest_node_id: self.latest_node_id.clone(),
            death_row: self.death_row.clone(),
            cache_leaf_modified: self.cache_leaf_modified.clone(),
            _hasher: PhantomData,
        }
    }
}

#[derive(Clone, Debug, PartialEq, Eq)]
pub(crate) enum InsertOrRemove<T> {
    Insert(T),
    Remove,
}
enum NodeOrFelt<'a> {
    Node(&'a Node),
    Felt(Felt),
}

impl<H: StarkHash + Send + Sync> MerkleTree<H> {
    /// Less visible initialization for `MerkleTree<T>` as the main entry points should be
    /// [`MerkleTree::<RcNodeStorage>::load`] for persistent trees and [`MerkleTree::empty`] for
    /// transient ones.

    pub fn new<DB: BonsaiDatabase, ID: Id>(
        db: &mut KeyValueDB<DB, ID>,
        identifier: Vec<u8>,
    ) -> Result<Self, BonsaiStorageError<DB::DatabaseError>> {
        let nodes_mapping: HashMap<NodeId, Node> = HashMap::new();
        let root_node = db.get(&TrieKey::new(&identifier, TrieKeyType::Trie, &[]))?;
        let node = if let Some(root_node) = root_node {
            Node::decode(&mut root_node.as_slice())?
        } else {
            db.insert(
                &TrieKey::new(&identifier, TrieKeyType::Trie, &[]),
                &Node::Unresolved(Felt::ZERO).encode(),
                None,
            )?;
            Node::Unresolved(Felt::ZERO)
        };
        // SAFETY: The root node has been created just above
        let root = node.hash().unwrap();
        Ok(Self {
            root_handle: NodeHandle::Hash(root),
            root_hash: root,
            identifier,
            storage_nodes: NodesMapping(nodes_mapping),
            latest_node_id: NodeId(0),
            death_row: Vec::new(),
            cache_leaf_modified: HashMap::new(),
            _hasher: PhantomData,
        })
    }

    pub fn root_hash(&self) -> Felt {
        self.root_hash
    }

    /// Remove all the modifications that have been done since the last commit.
    pub fn reset_to_last_commit<DB: BonsaiDatabase, ID: Id>(
        &mut self,
        db: &mut KeyValueDB<DB, ID>,
    ) -> Result<(), BonsaiStorageError<DB::DatabaseError>> {
        let node = self
            .get_trie_branch_in_db_from_path(db, &Path(BitVec::<u8, Msb0>::new()))?
            .ok_or(BonsaiStorageError::Trie(
                "root node doesn't exist in the storage".to_string(),
            ))?;
        let node_hash = node.hash().ok_or(BonsaiStorageError::Trie(
            "Root doesn't exist in the storage".to_string(),
        ))?;
        self.latest_node_id.reset();
        self.storage_nodes.0.clear();
        self.cache_leaf_modified.clear();
        self.root_handle = NodeHandle::Hash(node_hash);
        self.root_hash = node_hash;
        Ok(())
    }

    /// Calculate all the new hashes and the root hash.
    #[allow(clippy::type_complexity)]
    pub(crate) fn get_updates<DB: BonsaiDatabase>(
        &mut self,
    ) -> Result<Vec<(TrieKey, InsertOrRemove<Vec<u8>>)>, BonsaiStorageError<DB::DatabaseError>>
    {
        let mut updates = vec![];
        for node_key in mem::take(&mut self.death_row) {
            updates.push((node_key, InsertOrRemove::Remove));
        }

        let mut hashes = vec![];
        self.compute_root_hash::<DB>(&mut hashes)?;
        let root_hash = self.commit_subtree::<DB>(
            &mut updates,
            self.root_handle,
            Path(BitVec::new()),
            &mut hashes.drain(..),
        )?;

        for (key, value) in mem::take(&mut self.cache_leaf_modified) {
            updates.push((
                TrieKey::new(&self.identifier, TrieKeyType::Flat, &key),
                match value {
                    InsertOrRemove::Insert(value) => InsertOrRemove::Insert(value.encode()),
                    InsertOrRemove::Remove => InsertOrRemove::Remove,
                },
            ));
        }
        self.latest_node_id.reset();
        self.root_hash = root_hash;
        self.root_handle = NodeHandle::Hash(root_hash);
        Ok(updates)
    }

    fn get_node_or_felt<DB: BonsaiDatabase>(
        &self,
        node_handle: &NodeHandle,
    ) -> Result<NodeOrFelt, BonsaiStorageError<DB::DatabaseError>> {
        let node_id = match node_handle {
            NodeHandle::Hash(hash) => return Ok(NodeOrFelt::Felt(*hash)),
            NodeHandle::InMemory(root_id) => root_id,
        };
        let node = self
            .storage_nodes
            .0
            .get(node_id)
            .ok_or(BonsaiStorageError::Trie(
                "Couldn't fetch node in the temporary storage".to_string(),
            ))?;
        Ok(NodeOrFelt::Node(node))
    }

    fn compute_root_hash<DB: BonsaiDatabase>(
        &self,
        hashes: &mut Vec<Felt>,
    ) -> Result<Felt, BonsaiStorageError<DB::DatabaseError>> {
        match self.get_node_or_felt::<DB>(&self.root_handle)? {
            NodeOrFelt::Felt(felt) => Ok(felt),
            NodeOrFelt::Node(node) => self.compute_hashes::<DB>(node, Path(BitVec::new()), hashes),
        }
    }

    fn compute_hashes<DB: BonsaiDatabase>(
        &self,
        node: &Node,
        path: Path,
        hashes: &mut Vec<Felt>,
    ) -> Result<Felt, BonsaiStorageError<DB::DatabaseError>> {
        use Node::*;

        match node {
            Unresolved(hash) => Ok(*hash),
            Binary(binary) => {
                // we check if we have one or two changed children

                let left_path = path.new_with_direction(Direction::Left);
                let node_left = self.get_node_or_felt::<DB>(&binary.left)?;
                let right_path = path.new_with_direction(Direction::Right);
                let node_right = self.get_node_or_felt::<DB>(&binary.right)?;

                let (left_hash, right_hash) = match (node_left, node_right) {
                    #[cfg(feature = "std")]
                    (NodeOrFelt::Node(left), NodeOrFelt::Node(right)) => {
                        // two children: use rayon
                        let (left, right) = rayon::join(
                            || self.compute_hashes::<DB>(left, left_path, hashes),
                            || {
                                let mut hashes = vec![];
                                let felt =
                                    self.compute_hashes::<DB>(right, right_path, &mut hashes)?;
                                Ok::<_, BonsaiStorageError<DB::DatabaseError>>((felt, hashes))
                            },
                        );
                        let (left_hash, (right_hash, hashes2)) = (left?, right?);
                        hashes.extend(hashes2);

                        (left_hash, right_hash)
                    }
                    (left, right) => {
                        let left_hash = match left {
                            NodeOrFelt::Felt(felt) => felt,
                            NodeOrFelt::Node(node) => {
                                self.compute_hashes::<DB>(node, left_path, hashes)?
                            }
                        };
                        let right_hash = match right {
                            NodeOrFelt::Felt(felt) => felt,
                            NodeOrFelt::Node(node) => {
                                self.compute_hashes::<DB>(node, right_path, hashes)?
                            }
                        };
                        (left_hash, right_hash)
                    }
                };

                let hash = H::hash(&left_hash, &right_hash);
                hashes.push(hash);
                Ok(hash)
            }

            Edge(edge) => {
                let mut child_path = path.clone();
                child_path.0.extend(&edge.path.0);
                let child_hash = match self.get_node_or_felt::<DB>(&edge.child)? {
                    NodeOrFelt::Felt(felt) => felt,
                    NodeOrFelt::Node(node) => {
                        self.compute_hashes::<DB>(node, child_path, hashes)?
                    }
                };

                let mut bytes = [0u8; 32];
                bytes.view_bits_mut::<Msb0>()[256 - edge.path.0.len()..]
                    .copy_from_bitslice(&edge.path.0);

                let felt_path = Felt::from_bytes_be(&bytes);
                let mut length = [0; 32];
                // Safe as len() is guaranteed to be <= 251
                length[31] = edge.path.0.len() as u8;

                let length = Felt::from_bytes_be(&length);
                let hash = H::hash(&child_hash, &felt_path) + length;
                hashes.push(hash);
                Ok(hash)
            }
        }
    }

    /// Persists any changes in this subtree to storage.
    ///
    /// This necessitates recursively calculating the hash of, and
    /// in turn persisting, any changed child nodes. This is necessary
    /// as the parent node's hash relies on its children hashes.
    /// Hash computation is done in parallel with [`compute_hashes`] beforehand.
    ///
    /// In effect, the entire tree gets persisted.
    ///
    /// # Arguments
    ///
    /// * `node` - The top node from the subtree to commit.
    fn commit_subtree<DB: BonsaiDatabase>(
        &mut self,
        updates: &mut Vec<(TrieKey, InsertOrRemove<Vec<u8>>)>,
        node_handle: NodeHandle,
        path: Path,
        hashes: &mut impl Iterator<Item = Felt>,
    ) -> Result<Felt, BonsaiStorageError<DB::DatabaseError>> {
        use Node::*;
        let node_id = match node_handle {
            NodeHandle::Hash(hash) => return Ok(hash),
            NodeHandle::InMemory(root_id) => root_id,
        };

        match self
            .storage_nodes
            .0
            .remove(&node_id)
            .ok_or(BonsaiStorageError::Trie(
                "Couldn't fetch node in the temporary storage".to_string(),
            ))? {
            Unresolved(hash) => {
                if path.0.is_empty() {
                    updates.push((
                        TrieKey::new(&self.identifier, TrieKeyType::Trie, &[]),
                        InsertOrRemove::Insert(Node::Unresolved(hash).encode()),
                    ));
                    Ok(hash)
                } else {
                    Ok(hash)
                }
            }
            Binary(mut binary) => {
                let left_path = path.new_with_direction(Direction::Left);
                let left_hash =
                    self.commit_subtree::<DB>(updates, binary.left, left_path, hashes)?;
                let right_path = path.new_with_direction(Direction::Right);
                let right_hash =
                    self.commit_subtree::<DB>(updates, binary.right, right_path, hashes)?;
                let hash = hashes.next().expect("mismatched hash state");
                binary.hash = Some(hash);
                binary.left = NodeHandle::Hash(left_hash);
                binary.right = NodeHandle::Hash(right_hash);
                let key_bytes: Vec<u8> = path.into();
                updates.push((
                    TrieKey::new(&self.identifier, TrieKeyType::Trie, &key_bytes),
                    InsertOrRemove::Insert(Node::Binary(binary).encode()),
                ));
                Ok(hash)
            }

            Edge(mut edge) => {
                let mut child_path = path.clone();
                child_path.0.extend(&edge.path.0);
                let child_hash =
                    self.commit_subtree::<DB>(updates, edge.child, child_path, hashes)?;
                let hash = hashes.next().expect("mismatched hash state");
                edge.hash = Some(hash);
                edge.child = NodeHandle::Hash(child_hash);
                let key_bytes: Vec<u8> = path.into();
                updates.push((
                    TrieKey::new(&self.identifier, TrieKeyType::Trie, &key_bytes),
                    InsertOrRemove::Insert(Node::Edge(edge).encode()),
                ));
                Ok(hash)
            }
        }
    }

    /// Sets the value of a key. To delete a key, set the value to [Felt::ZERO].
    ///
    /// # Arguments
    ///
    /// * `key` - The key to set.
    /// * `value` - The value to set.
    pub fn set<DB: BonsaiDatabase, ID: Id>(
        &mut self,
        db: &mut KeyValueDB<DB, ID>,
        key: &BitSlice<u8, Msb0>,
        value: Felt,
    ) -> Result<(), BonsaiStorageError<DB::DatabaseError>> {
        if value == Felt::ZERO {
            return self.delete_leaf(db, key);
        }
        let key_bytes = bitslice_to_bytes(key);
        if let Some(InsertOrRemove::Insert(value_db)) = self.cache_leaf_modified.get(&key_bytes) {
            if &value == value_db {
                return Ok(());
            }
        }
        if let Some(value_db) = db.get(&TrieKey::new(
            &self.identifier,
            TrieKeyType::Flat,
            &key_bytes,
        ))? {
            if value == Felt::decode(&mut value_db.as_slice()).unwrap() {
                return Ok(());
            }
        }
        let path = self.preload_nodes(db, key)?;
        // There are three possibilities.
        //
        // 1. The leaf exists, in which case we simply change its value.
        //
        // 2. The tree is empty, we insert the new leaf and the root becomes an edge node connecting to it.
        //
        // 3. The leaf does not exist, and the tree is not empty. The final node in the traversal will be an
        //    edge node who's path diverges from our new leaf node's.
        //
        //    This edge must be split into a new subtree containing both the existing edge's child and the
        //    new leaf. This requires an edge followed by a binary node and then further edges to both the
        //    current child and the new leaf. Any of these new edges may also end with an empty path in
        //    which case they should be elided. It depends on the common path length of the current edge
        //    and the new leaf i.e. the split may be at the first bit (in which case there is no leading
        //    edge), or the split may be in the middle (requires both leading and post edges), or the
        //    split may be the final bit (no post edge).
        use Node::*;
        match path.last() {
            Some(node_id) => {
                let mut nodes_to_add = Vec::new();
                self.storage_nodes.0.entry(*node_id).and_modify(|node| {
                    match node {
                        Edge(edge) => {
                            let common = edge.common_path(key);
                            // Height of the binary node
                            let branch_height = edge.height as usize + common.len();
                            if branch_height == key.len() {
                                edge.child = NodeHandle::Hash(value);
                                // The leaf already exists, we simply change its value.
                                self.cache_leaf_modified
                                    .insert(key_bytes, InsertOrRemove::Insert(value));
                                return;
                            }
                            // Height of the binary node's children
                            let child_height = branch_height + 1;

                            // Path from binary node to new leaf
                            let new_path = key[child_height..].to_bitvec();
                            // Path from binary node to existing child
                            let old_path = edge.path.0[common.len() + 1..].to_bitvec();

                            // The new leaf branch of the binary node.
                            // (this may be edge -> leaf, or just leaf depending).
                            self.cache_leaf_modified
                                .insert(key_bytes, InsertOrRemove::Insert(value));

                            let new = if new_path.is_empty() {
                                NodeHandle::Hash(value)
                            } else {
                                let new_edge = Node::Edge(EdgeNode {
                                    hash: None,
                                    height: child_height as u64,
                                    path: Path(new_path),
                                    child: NodeHandle::Hash(value),
                                });
                                let edge_id = self.latest_node_id.next_id();
                                nodes_to_add.push((edge_id, new_edge));
                                NodeHandle::InMemory(edge_id)
                            };

                            // The existing child branch of the binary node.
                            let old = if old_path.is_empty() {
                                edge.child
                            } else {
                                let old_edge = Node::Edge(EdgeNode {
                                    hash: None,
                                    height: child_height as u64,
                                    path: Path(old_path),
                                    child: edge.child,
                                });
                                let edge_id = self.latest_node_id.next_id();
                                nodes_to_add.push((edge_id, old_edge));
                                NodeHandle::InMemory(edge_id)
                            };

                            let new_direction = Direction::from(key[branch_height]);
                            let (left, right) = match new_direction {
                                Direction::Left => (new, old),
                                Direction::Right => (old, new),
                            };

                            let branch = Node::Binary(BinaryNode {
                                hash: None,
                                height: branch_height as u64,
                                left,
                                right,
                            });

                            // We may require an edge leading to the binary node.
                            let new_node = if common.is_empty() {
                                branch
                            } else {
                                let branch_id = self.latest_node_id.next_id();
                                nodes_to_add.push((branch_id, branch));

                                Node::Edge(EdgeNode {
                                    hash: None,
                                    height: edge.height,
                                    path: Path(common.to_bitvec()),
                                    child: NodeHandle::InMemory(branch_id),
                                })
                            };
                            let path = key[..edge.height as usize].to_bitvec();
                            let key_bytes =
                                [&[path.len() as u8], path.into_vec().as_slice()].concat();
                            self.death_row.push(TrieKey::Trie(key_bytes));
                            *node = new_node;
                        }
                        Binary(binary) => {
                            if (binary.height + 1) as usize == key.len() {
                                let direction = Direction::from(key[binary.height as usize]);
                                match direction {
                                    Direction::Left => binary.left = NodeHandle::Hash(value),
                                    Direction::Right => binary.right = NodeHandle::Hash(value),
                                };
                            }
                        }
                        _ => {}
                    }
                });
                for (id, node) in nodes_to_add {
                    self.storage_nodes.0.insert(id, node);
                }
                Ok(())
            }
            None => {
                // Getting no travel nodes implies that the tree is empty.
                //
                // Create a new leaf node with the value, and the root becomes
                // an edge node connecting to the leaf.
                let edge = Node::Edge(EdgeNode {
                    hash: None,
                    height: 0,
                    path: Path(key.to_bitvec()),
                    child: NodeHandle::Hash(value),
                });
                self.storage_nodes
                    .0
                    .insert(self.latest_node_id.next_id(), edge);

                self.root_handle = NodeHandle::InMemory(self.latest_node_id);

                let key_bytes = bitslice_to_bytes(key);
                self.cache_leaf_modified
                    .insert(key_bytes, InsertOrRemove::Insert(value));
                Ok(())
            }
        }
    }

    /// Deletes a leaf node from the tree.
    ///
    /// This is not an external facing API; the functionality is instead accessed by calling
    /// [`MerkleTree::set`] with value set to [`Felt::ZERO`].
    ///
    /// # Arguments
    ///
    /// * `key` - The key to delete.
    fn delete_leaf<DB: BonsaiDatabase, ID: Id>(
        &mut self,
        db: &mut KeyValueDB<DB, ID>,
        key: &BitSlice<u8, Msb0>,
    ) -> Result<(), BonsaiStorageError<DB::DatabaseError>> {
        // Algorithm explanation:
        //
        // The leaf's parent node is either an edge, or a binary node.
        // If it's an edge node, then it must also be deleted. And its parent
        // must be a binary node. In either case we end up with a binary node
        // who's one child is deleted. This changes the binary to an edge node.
        //
        // Note that its possible that there is no binary node -- if the resulting tree would be empty.
        //
        // This new edge node may need to merge with the old binary node's parent node
        // and other remaining child node -- if they're also edges.
        //
        // Then we are done.
        let key_bytes = bitslice_to_bytes(key);
        if db
            .get(&TrieKey::new(
                &self.identifier,
                TrieKeyType::Flat,
                &key_bytes,
            ))?
            .is_none()
            && !self.cache_leaf_modified.contains_key(&key_bytes)
        {
            return Ok(());
        }
        self.cache_leaf_modified
            .insert(key_bytes.clone(), InsertOrRemove::Remove);

        let path = self.preload_nodes(db, key)?;

        let mut last_binary_path = Path(key.to_bitvec());

        // Go backwards until we hit a branch node.
        let mut node_iter = path.into_iter().rev().skip_while(|node| {
            // SAFETY: Has been populate by preload_nodes just above
            let node = self.storage_nodes.0.get(node).unwrap();
            match node {
                Node::Unresolved(_) => {}
                Node::Binary(_) => {}
                Node::Edge(edge) => {
                    for _ in 0..edge.path.0.len() {
                        last_binary_path.0.pop();
                    }
                    let mut new_path = Path(BitVec::new());
                    for i in last_binary_path.0.iter() {
                        new_path.0.push(*i);
                    }
                    last_binary_path = new_path;
                    let path: Vec<u8> = (&last_binary_path).into();
                    self.death_row
                        .push(TrieKey::new(&self.identifier, TrieKeyType::Trie, &path));
                }
            }
            !node.is_binary()
        });
        let branch_node = node_iter.next();
        let parent_branch_node = node_iter.next();
        match branch_node {
            Some(node_id) => {
                let new_edge =
                    {
                        let node = self.storage_nodes.0.get_mut(&node_id).ok_or(
                            BonsaiStorageError::Trie("Node not found in memory".to_string()),
                        )?;
                        // SAFETY: This node must be a binary node due to the iteration condition.
                        let binary = node.as_binary().unwrap();
                        let (direction, height) =
                            { (binary.direction(key).invert(), binary.height) };
                        last_binary_path.0.pop();
                        last_binary_path.0.push(bool::from(direction));
                        // Create an edge node to replace the old binary node
                        // i.e. with the remaining child (note the direction invert),
                        //      and a path of just a single bit.
                        let path = Path(once(bool::from(direction)).collect::<BitVec<_, _>>());
                        let mut edge = EdgeNode {
                            hash: None,
                            height,
                            path,
                            child: match direction {
                                Direction::Left => binary.left,
                                Direction::Right => binary.right,
                            },
                        };

                        // Merge the remaining child if it's an edge.
                        self.merge_edges::<DB, ID>(&mut edge, db, &last_binary_path)?;
                        edge
                    };
                // Check the parent of the new edge. If it is also an edge, then they must merge.
                if let Some(parent_node_id) = parent_branch_node {
                    // Get a mutable reference to the parent node to merge them
                    let parent_node = self.storage_nodes.0.get_mut(&parent_node_id).ok_or(
                        BonsaiStorageError::Trie("Node not found in memory".to_string()),
                    )?;
                    if let Node::Edge(parent_edge) = parent_node {
                        parent_edge.path.0.extend_from_bitslice(&new_edge.path.0);
                        parent_edge.child = new_edge.child;
                    } else {
                        self.storage_nodes.0.insert(node_id, Node::Edge(new_edge));
                    }
                } else {
                    self.storage_nodes.0.insert(node_id, Node::Edge(new_edge));
                }
            }
            None => {
                // We reached the root without a hitting binary node. The new tree
                // must therefore be empty.
                self.latest_node_id.next_id();
                self.storage_nodes
                    .0
                    .insert(self.latest_node_id, Node::Unresolved(Felt::ZERO));
                self.root_handle = NodeHandle::InMemory(self.latest_node_id);
                self.root_hash = Felt::ZERO;
                return Ok(());
            }
        };
        Ok(())
    }

    /// Returns the value stored at key, or `None` if it does not exist.
    ///
    /// # Arguments
    ///
    /// * `key` - The key of the value to get.
    ///
    /// # Returns
    ///
    /// The value of the key.
    pub fn get<DB: BonsaiDatabase, ID: Id>(
        &self,
        db: &KeyValueDB<DB, ID>,
        key: &BitSlice<u8, Msb0>,
    ) -> Result<Option<Felt>, BonsaiStorageError<DB::DatabaseError>> {
        let key = bitslice_to_bytes(key);
        if let Some(value) = self.cache_leaf_modified.get(&key) {
            match value {
                InsertOrRemove::Remove => return Ok(None),
                InsertOrRemove::Insert(value) => return Ok(Some(*value)),
            }
        }
        db.get(&TrieKey::new(&self.identifier, TrieKeyType::Flat, &key))
            .map(|r| r.map(|opt| Felt::decode(&mut opt.as_slice()).unwrap()))
    }

    pub fn contains<DB: BonsaiDatabase, ID: Id>(
        &self,
        db: &KeyValueDB<DB, ID>,
        key: &BitSlice<u8, Msb0>,
    ) -> Result<bool, BonsaiStorageError<DB::DatabaseError>> {
        let key = bitslice_to_bytes(key);
        if let Some(value) = self.cache_leaf_modified.get(&key) {
            match value {
                InsertOrRemove::Remove => return Ok(false),
                InsertOrRemove::Insert(_) => return Ok(true),
            }
        }
        db.contains(&TrieKey::new(&self.identifier, TrieKeyType::Flat, &key))
    }

    /// Returns the list of nodes along the path.
    ///
    /// if it exists, or down to the node which proves that the key does not exist.
    ///
    /// The nodes are returned in order, root first.
    ///
    /// Verification is performed by confirming that:
    ///   1. the chain follows the path of `key`, and
    ///   2. the hashes are correct, and
    ///   3. the root hash matches the known root
    ///
    /// # Arguments
    ///
    /// * `key` - The key to get the merkle proof of.
    ///
    /// # Returns
    ///
    /// The merkle proof and all the child nodes hashes.
    pub fn get_proof<DB: BonsaiDatabase, ID: Id>(
        &self,
        db: &KeyValueDB<DB, ID>,
        key: &BitSlice<u8, Msb0>,
    ) -> Result<Vec<ProofNode>, BonsaiStorageError<DB::DatabaseError>> {
        let mut nodes = Vec::with_capacity(251);
        let mut node = match self.root_handle {
            NodeHandle::Hash(_) => {
                let node = self
                    .get_trie_branch_in_db_from_path(db, &Path(BitVec::<u8, Msb0>::new()))?
                    .ok_or(BonsaiStorageError::Trie(
                        "Couldn't fetch root node in db".to_string(),
                    ))?;
                if node.is_empty() {
                    return Ok(Vec::new());
                }
                node
            }
            NodeHandle::InMemory(root_id) => self
                .storage_nodes
                .0
                .get(&root_id)
                .ok_or(BonsaiStorageError::Trie(
                    "Couldn't fetch root node in the temporary storage".to_string(),
                ))?
                .clone(),
        };
        loop {
            match node {
                Node::Edge(edge) => {
                    let child_path = key[..edge.height as usize + edge.path.0.len()].to_bitvec();
                    let child_node = match edge.child {
                        NodeHandle::Hash(hash) => {
                            let node =
                                self.get_trie_branch_in_db_from_path(db, &Path(child_path))?;
                            if let Some(node) = node {
                                node
                            } else {
                                nodes.push(ProofNode::Edge {
                                    child: hash,
                                    path: edge.path.clone(),
                                });
                                return Ok(nodes);
                            }
                        }
                        NodeHandle::InMemory(child_id) => self
                            .storage_nodes
                            .0
                            .get(&child_id)
                            .ok_or(BonsaiStorageError::Trie(
                                "Couldn't fetch child node in the temporary storage".to_string(),
                            ))?
                            .clone(),
                    };
                    nodes.push(ProofNode::Edge {
                        child: child_node.hash().ok_or(BonsaiStorageError::Trie(
                            "Couldn't fetch child node in the temporary storage".to_string(),
                        ))?,
                        path: edge.path.clone(),
                    });
                    if edge.path_matches(key) {
                        node = child_node;
                    } else {
                        return Ok(nodes);
                    }
                    if edge.common_path(key) == key {
                        return Ok(nodes);
                    }
                }
                Node::Binary(binary) => {
                    let next_direction = key
                        .get(binary.height as usize)
                        .map(|b| Direction::from(*b))
                        .ok_or(BonsaiStorageError::Trie("Key too short".to_string()))?;
                    let next = binary.get_child(next_direction);
                    let next_path = key[..binary.height as usize + 1].to_bitvec();
                    let next_node = match next {
                        NodeHandle::Hash(_) => self
                            .get_trie_branch_in_db_from_path(db, &Path(next_path))?
                            .ok_or(BonsaiStorageError::Trie(
                                "Couldn't fetch next node in db".to_string(),
                            ))?,
                        NodeHandle::InMemory(next_id) => self
                            .storage_nodes
                            .0
                            .get(&next_id)
                            .ok_or(BonsaiStorageError::Trie(
                                "Couldn't fetch next node in the temporary storage".to_string(),
                            ))?
                            .clone(),
                    };
                    let other = binary.get_child(next_direction.invert());
                    let other_hash = match other {
                        NodeHandle::Hash(hash) => hash,
                        NodeHandle::InMemory(other_id) => {
                            let other_node = self
                                .storage_nodes
                                .0
                                .get(&other_id)
                                .ok_or(BonsaiStorageError::Trie(
                                    "Couldn't fetch other node in the temporary storage"
                                        .to_string(),
                                ))?
                                .clone();
                            other_node.hash().ok_or(BonsaiStorageError::Trie(
                                "Couldn't fetch other node in the temporary storage".to_string(),
                            ))?
                        }
                    };
                    match next_direction {
                        Direction::Left => {
                            nodes.push(ProofNode::Binary {
                                left: next_node.hash().ok_or(BonsaiStorageError::Trie(
                                    "Couldn't fetch next node in the temporary storage".to_string(),
                                ))?,
                                right: other_hash,
                            });
                        }
                        Direction::Right => {
                            nodes.push(ProofNode::Binary {
                                left: other_hash,
                                right: next_node.hash().ok_or(BonsaiStorageError::Trie(
                                    "Couldn't fetch next node in the temporary storage".to_string(),
                                ))?,
                            });
                        }
                    }
                    node = next_node;
                }
                Node::Unresolved(hash) => {
                    nodes.push(ProofNode::Edge {
                        child: hash,
                        path: Path(BitVec::<u8, Msb0>::new()),
                    });
                    return Ok(nodes);
                }
            }
        }
    }

    /// preload_nodes from the current root towards the destination [Leaf](Node::Leaf) node.
    /// If the destination node exists, it will be the final node in the list.
    ///
    /// This means that the final node will always be either a the destination [Leaf](Node::Leaf)
    /// node, or an [Edge](Node::Edge) node who's path suffix does not match the leaf's path.
    ///
    /// The final node can __not__ be a [Binary](Node::Binary) node since it would always be
    /// possible to continue on towards the destination. Nor can it be an
    /// [Unresolved](Node::Unresolved) node since this would be resolved to check if we can
    /// travel further.
    ///
    /// # Arguments
    ///
    /// * `dst` - The node to get to.
    ///
    /// # Returns
    ///
    /// The list of nodes along the path.
    fn preload_nodes<DB: BonsaiDatabase, ID: Id>(
        &mut self,
        db: &mut KeyValueDB<DB, ID>,
        dst: &BitSlice<u8, Msb0>,
    ) -> Result<Vec<NodeId>, BonsaiStorageError<DB::DatabaseError>> {
        let mut nodes = Vec::with_capacity(251);
        let node_id = match self.root_handle {
            NodeHandle::Hash(_) => {
                let node = self
                    .get_trie_branch_in_db_from_path(db, &Path(BitVec::<u8, Msb0>::new()))?
                    .ok_or(BonsaiStorageError::Trie(
                        "Couldn't fetch root node in db".to_string(),
                    ))?;
                if node.is_empty() {
                    return Ok(Vec::new());
                }
                self.latest_node_id.next_id();
                self.root_handle = NodeHandle::InMemory(self.latest_node_id);
                self.storage_nodes.0.insert(self.latest_node_id, node);
                nodes.push(self.latest_node_id);
                self.latest_node_id
            }
            NodeHandle::InMemory(root_id) => {
                nodes.push(root_id);
                root_id
            }
        };
        self.preload_nodes_subtree(
            db,
            dst,
            node_id,
            Path(BitVec::<u8, Msb0>::new()),
            &mut nodes,
        )?;
        Ok(nodes)
    }

    fn preload_nodes_subtree<DB: BonsaiDatabase, ID: Id>(
        &mut self,
        db: &mut KeyValueDB<DB, ID>,
        dst: &BitSlice<u8, Msb0>,
        root_id: NodeId,
        mut path: Path,
        nodes: &mut Vec<NodeId>,
    ) -> Result<(), BonsaiStorageError<DB::DatabaseError>> {
        let node = self
            .storage_nodes
            .0
            .get(&root_id)
            .ok_or(BonsaiStorageError::Trie(
                "Couldn't fetch node in the temporary storage".to_string(),
            ))?
            .clone();
        match node {
            // We are in a case where the trie is empty and so there is nothing to preload.
            Node::Unresolved(_hash) => Ok(()),
            // We are checking which side of the binary we should load in memory (if we don't have it already)
            // We load this "child-side" node in the memory and refer his memory handle in the binary node.
            // We also add the "child-side" node in the list that accumulate all the nodes we want to preload.
            // We override the binary node in the memory with this new version that has the "child-side" memory handle
            // instead of the hash.
            // We call recursively the function with the "child-side" node.
            Node::Binary(mut binary_node) => {
                let next_direction = binary_node.direction(dst);
                path.0.push(bool::from(next_direction));
                let next = binary_node.get_child(next_direction);
                match next {
                    NodeHandle::Hash(_) => {
                        let node = self.get_trie_branch_in_db_from_path(db, &path)?;
                        if let Some(node) = node {
                            self.latest_node_id.next_id();
                            self.storage_nodes.0.insert(self.latest_node_id, node);
                            nodes.push(self.latest_node_id);
                            match next_direction {
                                Direction::Left => {
                                    binary_node.left = NodeHandle::InMemory(self.latest_node_id)
                                }
                                Direction::Right => {
                                    binary_node.right = NodeHandle::InMemory(self.latest_node_id)
                                }
                            };
                            self.storage_nodes
                                .0
                                .insert(root_id, Node::Binary(binary_node));
                            self.preload_nodes_subtree(db, dst, self.latest_node_id, path, nodes)
                        } else {
                            Ok(())
                        }
                    }
                    NodeHandle::InMemory(next_id) => {
                        nodes.push(next_id);
                        self.preload_nodes_subtree(db, dst, next_id, path, nodes)
                    }
                }
            }
            // If the edge node match the path we want to preload then we load the child node in memory (if we don't have it already)
            // and we override the edge node in the memory with this new version that has the child memory handle instead of the hash.
            // We also add the child node in the list that accumulate all the nodes we want to preload.
            // We call recursively the function with the child node.
            Node::Edge(mut edge_node) if edge_node.path_matches(dst) => {
                path.0.extend_from_bitslice(&edge_node.path.0);
                if path.0 == dst {
                    return Ok(());
                }
                let next = edge_node.child;
                match next {
                    NodeHandle::Hash(_) => {
                        let node = self.get_trie_branch_in_db_from_path(db, &path)?;
                        if let Some(node) = node {
                            self.latest_node_id.next_id();
                            self.storage_nodes.0.insert(self.latest_node_id, node);
                            nodes.push(self.latest_node_id);
                            edge_node.child = NodeHandle::InMemory(self.latest_node_id);
                            self.storage_nodes.0.insert(root_id, Node::Edge(edge_node));
                            self.preload_nodes_subtree(db, dst, self.latest_node_id, path, nodes)
                        } else {
                            Ok(())
                        }
                    }
                    NodeHandle::InMemory(next_id) => {
                        nodes.push(next_id);
                        self.preload_nodes_subtree(db, dst, next_id, path, nodes)
                    }
                }
            }
            // We are in a case where the edge node doesn't match the path we want to preload so we return nothing.
            Node::Edge(_) => Ok(()),
        }
    }

    /// Get the node of the trie that corresponds to the path.
    fn get_trie_branch_in_db_from_path<DB: BonsaiDatabase, ID: Id>(
        &self,
        db: &KeyValueDB<DB, ID>,
        path: &Path,
    ) -> Result<Option<Node>, BonsaiStorageError<DB::DatabaseError>> {
        let path: Vec<u8> = path.into();
        db.get(&TrieKey::new(&self.identifier, TrieKeyType::Trie, &path))?
            .map(|node| {
                Node::decode(&mut node.as_slice()).map_err(|err| {
                    BonsaiStorageError::Trie(format!("Couldn't decode node: {}", err))
                })
            })
            .map_or(Ok(None), |r| r.map(Some))
    }

    /// This is a convenience function which merges the edge node with its child __iff__ it is also
    /// an edge.
    ///
    /// Does nothing if the child is not also an edge node.
    ///
    /// This can occur when mutating the tree (e.g. deleting a child of a binary node), and is an
    /// illegal state (since edge nodes __must be__ maximal subtrees).
    ///
    /// # Arguments
    ///
    /// * `parent` - The parent node to merge the child with.
    fn merge_edges<DB: BonsaiDatabase, ID: Id>(
        &self,
        parent: &mut EdgeNode,
        db: &KeyValueDB<DB, ID>,
        path: &Path,
    ) -> Result<(), BonsaiStorageError<DB::DatabaseError>> {
        let child_node = match parent.child {
            NodeHandle::Hash(_) => {
                let node = self.get_trie_branch_in_db_from_path(db, path)?;
                if let Some(node) = node {
                    node
                } else {
                    return Ok(());
                }
            }
            NodeHandle::InMemory(child_id) => self
                .storage_nodes
                .0
                .get(&child_id)
                .ok_or(BonsaiStorageError::Trie(
                    "Couldn't fetch node in memory".to_string(),
                ))?
                .clone(),
        };
        if let Node::Edge(child_edge) = child_node {
            parent.path.0.extend_from_bitslice(&child_edge.path.0);
            parent.child = child_edge.child;
        }
        Ok(())
    }

    /// Function that come from pathfinder_merkle_tree::merkle_tree::MerkleTree
    /// Verifies that the key `key` with value `value` is indeed part of the MPT that has root
    /// `root`, given `proofs`.
    /// Supports proofs of non-membership as well as proof of membership: this function returns
    /// an enum corresponding to the membership of `value`, or returns `None` in case of a hash mismatch.
    /// The algorithm follows this logic:
    /// 1. init expected_hash <- root hash
    /// 2. loop over nodes: current <- nodes[i]
    ///    1. verify the current node's hash matches expected_hash (if not then we have a bad proof)
    ///    2. move towards the target - if current is:
    ///       1. binary node then choose the child that moves towards the target, else if
    ///       2. edge node then check the path against the target bits
    ///          1. If it matches then proceed with the child, else
    ///          2. if it does not match then we now have a proof that the target does not exist
    ///    3. nibble off target bits according to which child you got in (2). If all bits are gone then you
    ///       have reached the target and the child hash is the value you wanted and the proof is complete.
    ///    4. set expected_hash <- to the child hash
    /// 3. check that the expected_hash is `value` (we should've reached the leaf)
    pub fn verify_proof(
        root: Felt,
        key: &BitSlice<u8, Msb0>,
        value: Felt,
        proofs: &[ProofNode],
    ) -> Option<Membership> {
        // Protect from ill-formed keys
        if key.len() > 251 {
            return None;
        }

        let mut expected_hash = root;
        let mut remaining_path: &BitSlice<u8, Msb0> = key;

        for proof_node in proofs.iter() {
            // Hash mismatch? Return None.
            if proof_node.hash::<H>() != expected_hash {
                return None;
            }
            match proof_node {
                ProofNode::Binary { left, right } => {
                    // Direction will always correspond to the 0th index
                    // because we're removing bits on every iteration.
                    let direction = Direction::from(remaining_path[0]);

                    // Set the next hash to be the left or right hash,
                    // depending on the direction
                    expected_hash = match direction {
                        Direction::Left => *left,
                        Direction::Right => *right,
                    };

                    // Advance by a single bit
                    remaining_path = &remaining_path[1..];
                }
                ProofNode::Edge { child, path } => {
                    if path.0 != remaining_path[..path.0.len()] {
                        // If paths don't match, we've found a proof of non membership because we:
                        // 1. Correctly moved towards the target insofar as is possible, and
                        // 2. hashing all the nodes along the path does result in the root hash, which means
                        // 3. the target definitely does not exist in this tree
                        return Some(Membership::NonMember);
                    }

                    // Set the next hash to the child's hash
                    expected_hash = *child;

                    // Advance by the whole edge path
                    remaining_path = &remaining_path[path.0.len()..];
                }
            }
        }

        // At this point, we should reach `value` !
        if expected_hash == value {
            Some(Membership::Member)
        } else {
            // Hash mismatch. Return `None`.
            None
        }
    }

    #[cfg(test)]
    #[allow(dead_code)]
    fn display(&self) {
        match self.root_handle {
            NodeHandle::Hash(hash) => {
                trace!("root is hash: {:?}", hash);
            }
            NodeHandle::InMemory(root_id) => {
                trace!("root is node: {:?}", root_id);
                self.print(&root_id);
            }
        }
    }

    #[cfg(test)]
    #[allow(dead_code)]
    fn print(&self, head: &NodeId) {
        use Node::*;

        let current_tmp = self.storage_nodes.0.get(head).unwrap().clone();
        trace!("bonsai_node {:?} = {:?}", head, current_tmp);

        match current_tmp {
            Unresolved(hash) => {
                trace!("Unresolved: {:?}", hash);
            }
            Binary(binary) => {
                match &binary.get_child(Direction::Left) {
                    NodeHandle::Hash(hash) => {
                        trace!("left is hash {:?}", hash);
                    }
                    NodeHandle::InMemory(left_id) => {
                        self.print(left_id);
                    }
                }
                match &binary.get_child(Direction::Right) {
                    NodeHandle::Hash(hash) => {
                        trace!("right is hash {:?}", hash);
                    }
                    NodeHandle::InMemory(right_id) => {
                        self.print(right_id);
                    }
                }
            }
            Edge(edge) => match &edge.child {
                NodeHandle::Hash(hash) => {
                    trace!("child is hash {:?}", hash);
                }
                NodeHandle::InMemory(child_id) => {
                    self.print(child_id);
                }
            },
        };
    }
}

pub(crate) fn bitslice_to_bytes(bitslice: &BitSlice<u8, Msb0>) -> Vec<u8> {
    [&[bitslice.len() as u8], bitslice.to_bitvec().as_raw_slice()].concat()
}

pub(crate) fn bytes_to_bitvec(bytes: &[u8]) -> BitVec<u8, Msb0> {
    BitSlice::from_slice(&bytes[1..]).to_bitvec()
}

#[cfg(test)]
#[cfg(all(test, feature = "std"))]
mod tests {
    // use crate::{
    //     databases::{create_rocks_db, RocksDB, RocksDBConfig},
    //     id::BasicId,
    //     key_value_db::KeyValueDBConfig,
    //     KeyValueDB,
    // };
    // use bitvec::vec::BitVec;
    // use mp_felt::Felt252Wrapper;
    // use mp_hashers::pedersen::PedersenHasher;
    // use parity_scale_codec::{Decode, Encode};
    // use rand::prelude::*;
    // use starknet_types_core::{felt::Felt, hash::Pedersen};

    // // convert a Madara felt to a standard Felt
    // fn felt_from_madara_felt(madara_felt: &Felt252Wrapper) -> Felt {
    //     let encoded = madara_felt.encode();
    //     Felt::decode(&mut &encoded[..]).unwrap()
    // }

    // // convert a standard Felt to a Madara felt
    // fn madara_felt_from_felt(felt: &Felt) -> Felt252Wrapper {
    //     let encoded = felt.encode();
    //     Felt252Wrapper::decode(&mut &encoded[..]).unwrap()
    // }

    // #[test]
    // fn one_commit_tree_compare() {
    //     let mut elements = vec![];
    //     let tempdir = tempfile::tempdir().unwrap();
    //     let mut rng = rand::thread_rng();
    //     let tree_size = rng.gen_range(10..100);
    //     for _ in 0..tree_size {
    //         let mut element = String::from("0x");
    //         let element_size = rng.gen_range(10..32);
    //         for _ in 0..element_size {
    //             let random_byte: u8 = rng.gen();
    //             element.push_str(&format!("{:02x}", random_byte));
    //         }
    //         elements.push(Felt::from_hex(&element).unwrap());
    //     }
    //     let madara_elements = elements
    //         .iter()
    //         .map(madara_felt_from_felt)
    //         .collect::<Vec<_>>();
    //     let rocks_db = create_rocks_db(std::path::Path::new(tempdir.path())).unwrap();
    //     let rocks_db = RocksDB::new(&rocks_db, RocksDBConfig::default());
    //     let db = KeyValueDB::new(rocks_db, KeyValueDBConfig::default(), None);
    //     let mut bonsai_tree: super::MerkleTree<Pedersen, RocksDB<BasicId>, BasicId> =
    //         super::MerkleTree::new(db).unwrap();
    //     let root_hash = mp_commitments::calculate_class_commitment_tree_root_hash::<PedersenHasher>(
    //         &madara_elements,
    //     );
    //     elements
    //         .iter()
    //         .zip(madara_elements.iter())
    //         .for_each(|(element, madara_element)| {
    //             let final_hash =
    //                 calculate_class_commitment_leaf_hash::<PedersenHasher>(*madara_element);
    //             let key = &element.to_bytes_be()[..31];
    //             bonsai_tree
    //                 .set(
    //                     &BitVec::from_vec(key.to_vec()),
    //                     felt_from_madara_felt(&final_hash),
    //                 )
    //                 .unwrap();
    //         });
    //     bonsai_tree.display();
    //     assert_eq!(
    //         bonsai_tree.commit().unwrap(),
    //         felt_from_madara_felt(&root_hash)
    //     );
    // }

    // #[test]
    // fn simple_commits() {
    //     let tempdir = tempfile::tempdir().unwrap();
    //     let mut madara_tree = StateCommitmentTree::<PedersenHasher>::default();
    //     let rocks_db = create_rocks_db(std::path::Path::new(tempdir.path())).unwrap();
    //     let rocks_db = RocksDB::new(&rocks_db, RocksDBConfig::default());
    //     let db = KeyValueDB::new(rocks_db, KeyValueDBConfig::default(), None);
    //     let mut bonsai_tree: super::MerkleTree<Pedersen, RocksDB<BasicId>, BasicId> =
    //         super::MerkleTree::new(db).unwrap();
    //     let elements = [
    //         [Felt::from_hex("0x665342762FDD54D0303c195fec3ce2568b62052e").unwrap()],
    //         [Felt::from_hex("0x66342762FDD54D0303c195fec3ce2568b62052e").unwrap()],
    //         [Felt::from_hex("0x66342762FDD54D033c195fec3ce2568b62052e").unwrap()],
    //     ];
    //     for elem in elements {
    //         elem.iter().for_each(|class_hash| {
    //             let final_hash =
    //                 felt_from_madara_felt(&calculate_class_commitment_leaf_hash::<PedersenHasher>(
    //                     madara_felt_from_felt(class_hash),
    //                 ));
    //             madara_tree.set(
    //                 madara_felt_from_felt(class_hash),
    //                 madara_felt_from_felt(&final_hash),
    //             );
    //             let key = &class_hash.to_bytes_be()[..31];
    //             bonsai_tree
    //                 .set(&BitVec::from_vec(key.to_vec()), final_hash)
    //                 .unwrap();
    //         });
    //     }
    //     let madara_root_hash = madara_tree.commit();
    //     let bonsai_root_hash = bonsai_tree.commit().unwrap();
    //     assert_eq!(bonsai_root_hash, felt_from_madara_felt(&madara_root_hash));
    // }

    // #[test]
    // fn simple_commits_and_delete() {
    //     let tempdir = tempfile::tempdir().unwrap();
    //     let rocks_db = create_rocks_db(std::path::Path::new(tempdir.path())).unwrap();
    //     let rocks_db = RocksDB::new(&rocks_db, RocksDBConfig::default());
    //     let db = KeyValueDB::new(rocks_db, KeyValueDBConfig::default(), None);
    //     let mut bonsai_tree: super::MerkleTree<Pedersen, RocksDB<BasicId>, BasicId> =
    //         super::MerkleTree::new(db).unwrap();
    //     let elements = [
    //         [Felt::from_hex("0x665342762FDD54D0303c195fec3ce2568b62052e").unwrap()],
    //         [Felt::from_hex("0x66342762FDD54D0303c195fec3ce2568b62052e").unwrap()],
    //         [Felt::from_hex("0x66342762FDD54D033c195fec3ce2568b62052e").unwrap()],
    //     ];
    //     for elem in elements {
    //         elem.iter().for_each(|class_hash| {
    //             let final_hash = calculate_class_commitment_leaf_hash::<PedersenHasher>(
    //                 madara_felt_from_felt(class_hash),
    //             );
    //             let key = &class_hash.to_bytes_be()[..31];
    //             bonsai_tree
    //                 .set(
    //                     &BitVec::from_vec(key.to_vec()),
    //                     felt_from_madara_felt(&final_hash),
    //                 )
    //                 .unwrap();
    //         });
    //     }
    //     bonsai_tree.commit().unwrap();
    //     for elem in elements {
    //         elem.iter().for_each(|class_hash| {
    //             let key = &class_hash.to_bytes_be()[..31];
    //             bonsai_tree
    //                 .set(&BitVec::from_vec(key.to_vec()), Felt::ZERO)
    //                 .unwrap();
    //         });
    //     }
    //     bonsai_tree.commit().unwrap();
    // }

    // #[test]
    // fn multiple_commits_tree_compare() {
    //     let mut rng = rand::thread_rng();
    //     let tempdir = tempfile::tempdir().unwrap();
    //     let mut madara_tree = StateCommitmentTree::<PedersenHasher>::default();
    //     let rocks_db = create_rocks_db(std::path::Path::new(tempdir.path())).unwrap();
    //     let rocks_db = RocksDB::new(&rocks_db, RocksDBConfig::default());
    //     let db = KeyValueDB::new(rocks_db, KeyValueDBConfig::default(), None);
    //     let mut bonsai_tree: super::MerkleTree<Pedersen, RocksDB<BasicId>, BasicId> =
    //         super::MerkleTree::new(db).unwrap();
    //     let nb_commits = rng.gen_range(2..4);
    //     for _ in 0..nb_commits {
    //         let mut elements = vec![];
    //         let tree_size = rng.gen_range(10..100);
    //         for _ in 0..tree_size {
    //             let mut element = String::from("0x");
    //             let element_size = rng.gen_range(10..32);
    //             for _ in 0..element_size {
    //                 let random_byte: u8 = rng.gen();
    //                 element.push_str(&format!("{:02x}", random_byte));
    //             }
    //             elements.push(Felt::from_hex(&element).unwrap());
    //         }
    //         elements.iter().for_each(|class_hash| {
    //             let final_hash = calculate_class_commitment_leaf_hash::<PedersenHasher>(
    //                 madara_felt_from_felt(class_hash),
    //             );
    //             madara_tree.set(madara_felt_from_felt(class_hash), final_hash);
    //             let key = &class_hash.to_bytes_be()[..31];
    //             bonsai_tree
    //                 .set(
    //                     &BitVec::from_vec(key.to_vec()),
    //                     felt_from_madara_felt(&final_hash),
    //                 )
    //                 .unwrap();
    //         });

    //         let bonsai_root_hash = bonsai_tree.commit().unwrap();
    //         let madara_root_hash = madara_tree.commit();
    //         assert_eq!(bonsai_root_hash, felt_from_madara_felt(&madara_root_hash));
    //     }
    // }

    // #[test]    // fn multiple_commits_tree_compare_with_deletes() {
    //     let mut rng = rand::thread_rng();
    //     let mut madara_tree = StateCommitmentTree::<PedersenHasher>::default();
    //     let rocks_db = create_rocks_db(std::path::Path::new("test_db")).unwrap();
    //     let mut db = RocksDB::new(&rocks_db, RocksDBConfig::default());
    //     let mut bonsai_tree: super::MerkleTree<PedersenHasher, RocksDB> =
    //         super::MerkleTree::empty(&mut db);
    //     let nb_commits = rng.gen_range(2..5);
    //     let mut elements_to_delete = vec![];
    //     for _ in 0..nb_commits {
    //         let mut elements = vec![];
    //         let tree_size = rng.gen_range(10..100);
    //         for _ in 0..tree_size {
    //             let mut element = String::from("0x");
    //             let element_size = rng.gen_range(10..32);
    //             for _ in 0..element_size {
    //                 let random_byte: u8 = rng.gen();
    //                 element.push_str(&format!("{:02x}", random_byte));
    //             }
    //             if rng.gen_bool(0.1) {
    //                 elements_to_delete.push(Felt::from_hex_be(&element).unwrap());
    //                 elements.push(Felt::from_hex_be(&element).unwrap());
    //             } else {
    //                 elements.push(Felt::from_hex_be(&element).unwrap());
    //             }
    //         }
    //         elements.iter().for_each(|class_hash| {
    //             let final_hash =
    //                 calculate_class_commitment_leaf_hash::<PedersenHasher>(*class_hash);
    //             madara_tree.set(*class_hash, final_hash);
    //             let key = &class_hash.0.to_bytes_be()[..31];
    //             bonsai_tree.set(&BitVec::from_vec(key.to_vec()), final_hash);
    //         });

    //         let bonsai_root_hash = bonsai_tree.commit();
    //         let madara_root_hash = madara_tree.commit();
    //         assert_eq!(bonsai_root_hash, madara_root_hash);
    //     }
    //     elements_to_delete.iter().for_each(|class_hash| {
    //         madara_tree.set(*class_hash, Felt::ZERO);
    //         let key = &class_hash.0.to_bytes_be()[..31];
    //         bonsai_tree.set(&BitVec::from_vec(key.to_vec()), Felt::ZERO);
    //     });

    //     let bonsai_root_hash = bonsai_tree.commit();
    //     let madara_root_hash = madara_tree.commit();
    //     assert_eq!(bonsai_root_hash, madara_root_hash);
    // }

    // #[test]
    // fn test_proof() {
    //     let tempdir = tempfile::tempdir().unwrap();
    //     let rocks_db = create_rocks_db(std::path::Path::new(tempdir.path())).unwrap();
    //     let rocks_db = RocksDB::new(&rocks_db, RocksDBConfig::default());
    //     let db = KeyValueDB::new(rocks_db, KeyValueDBConfig::default(), None);
    //     let mut bonsai_tree: super::MerkleTree<Pedersen, RocksDB<BasicId>, BasicId> =
    //         super::MerkleTree::new(db).unwrap();
    //     let elements = [
    //         [Felt252Wrapper::from_hex_be("0x665342762FDD54D0303c195fec3ce2568b62052e").unwrap()],
    //         [Felt252Wrapper::from_hex_be("0x66342762FDD54D0303c195fec3ce2568b62052e").unwrap()],
    //         [Felt252Wrapper::from_hex_be("0x66342762FDD54D033c195fec3ce2568b62052e").unwrap()],
    //     ];
    //     for elem in elements {
    //         elem.iter().for_each(|class_hash| {
    //             let final_hash =
    //                 calculate_class_commitment_leaf_hash::<PedersenHasher>(*class_hash);
    //             let key = &class_hash.0.to_bytes_be()[..31];
    //             bonsai_tree
    //                 .set(
    //                     &BitVec::from_vec(key.to_vec()),
    //                     Felt::from_bytes_be(&final_hash.0.to_bytes_be()),
    //                 )
    //                 .unwrap();
    //         });
    //     }
    //     bonsai_tree.commit().unwrap();
    //     let bonsai_proof = bonsai_tree
    //         .get_proof(&BitVec::from_vec(
    //             elements[0][0].0.to_bytes_be()[..31].to_vec(),
    //         ))
    //         .unwrap();
    //     println!("bonsai_proof: {:?}", bonsai_proof);
    // }

    // test in madara
    //     #[test]
    // fn test_proof() {
    //     let mut tree = super::merkle_patricia_tree::merkle_tree::MerkleTree::<PedersenHasher>::empty();
    //     let elements = [
    //         [Felt252Wrapper::from_hex_be("0x665342762FDD54D0303c195fec3ce2568b62052e").unwrap()],
    //         [Felt252Wrapper::from_hex_be("0x66342762FDD54D0303c195fec3ce2568b62052e").unwrap()],
    //         [Felt252Wrapper::from_hex_be("0x66342762FDD54D033c195fec3ce2568b62052e").unwrap()],
    //     ];
    //     for elem in elements {
    //         elem.iter().for_each(|class_hash| {
    //             let final_hash =
    //                 calculate_class_commitment_leaf_hash::<PedersenHasher>(*class_hash);
    //             let key = &class_hash.0.to_bytes_be()[..31];
    //             tree
    //                 .set(&BitVec::from_vec(key.to_vec()), final_hash)
    //         });
    //     }
    //     tree.commit();
    //     let bonsai_proof = tree.get_proof(&BitVec::from_vec(
    //         elements[0][0].0.to_bytes_be()[..31].to_vec(),
    //     ));
    //     println!("bonsai_proof: {:?}", bonsai_proof);
    // }
}
